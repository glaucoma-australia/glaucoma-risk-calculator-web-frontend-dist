var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Directive, ElementRef, HostListener, Input } from '@angular/core';
import { JsonSchemaFormService } from '../json-schema-form.service';
import { JsonPointer } from './index';
/**
 * OrderableDirective
 *
 * Enables array elements to be reordered by dragging and dropping.
 *
 * Only works for arrays that have at least two elements.
 *
 * Also detects arrays-within-arrays, and correctly moves either
 * the child array element or the parent array element,
 * depending on the drop targert.
 *
 */
var OrderableDirective = (function () {
    function OrderableDirective(elementRef, jsf) {
        this.elementRef = elementRef;
        this.jsf = jsf;
        this.listen = false;
        this.overParentElement = false;
        this.overChildElement = false;
    }
    OrderableDirective.prototype.ngOnInit = function () {
        if (this.orderable && this.layoutNode && this.layoutIndex && this.dataIndex) {
            this.element = this.elementRef.nativeElement;
            this.element.draggable = true;
            this.arrayPointer = JsonPointer.compile(JsonPointer.parse(this.jsf.getLayoutPointer(this)).slice(0, -1));
            this.listen = true;
        }
    };
    /**
     * Listeners for movable element being dragged:
     *
     * dragstart: add 'dragging' class to element, set effectAllowed = 'move'
     * dragover: set dropEffect = 'move'
     * dragend: remove 'dragging' class from element
     */
    OrderableDirective.prototype.onDragStart = function (event) {
        if (this.listen) {
            this.element.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            // Hack to bypass stupid HTML drag-and-drop dataTransfer protection
            // so drag source info will be available on dragenter
            sessionStorage.setItem(this.arrayPointer, this.dataIndex[this.dataIndex.length - 1] + '');
            event.dataTransfer.setData('text/plain', this.dataIndex[this.dataIndex.length - 1] + this.arrayPointer);
        }
    };
    OrderableDirective.prototype.onDragOver = function (event) {
        if (event.preventDefault)
            event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
        return false;
    };
    OrderableDirective.prototype.onDragEnd = function (event) {
        event.preventDefault();
        if (this.listen) {
            this.element.classList.remove('dragging');
        }
    };
    /**
     * Listeners for stationary items being dragged over:
     *
     * dragenter: add 'drag-target-...' class to element
     * dragleave: remove 'drag-target-...' class from element
     * drop: remove 'drag-target-...' class from element, move dropped array item
     */
    OrderableDirective.prototype.onDragEnter = function (event) {
        // Part 1 of a hack, inspired by Dragster, to simulate mouseover and mouseout
        // behavior while dragging items - http://bensmithett.github.io/dragster/
        if (this.overParentElement) {
            return this.overChildElement = true;
        }
        else {
            this.overParentElement = true;
        }
        if (this.listen) {
            var sourceArrayIndex = sessionStorage.getItem(this.arrayPointer);
            if (sourceArrayIndex !== null) {
                if (this.dataIndex[this.dataIndex.length - 1] < +sourceArrayIndex) {
                    this.element.classList.add('drag-target-top');
                }
                else if (this.dataIndex[this.dataIndex.length - 1] > +sourceArrayIndex) {
                    this.element.classList.add('drag-target-bottom');
                }
            }
        }
    };
    OrderableDirective.prototype.onDragLeave = function (event) {
        // Part 2 of the Dragster hack
        if (this.overChildElement) {
            this.overChildElement = false;
        }
        else if (this.overParentElement) {
            this.overParentElement = false;
        }
        if (!this.overParentElement && !this.overChildElement && this.listen) {
            this.element.classList.remove('drag-target-top');
            this.element.classList.remove('drag-target-bottom');
        }
    };
    OrderableDirective.prototype.onDrop = function (event) {
        if (this.listen) {
            this.element.classList.remove('drag-target-top');
            this.element.classList.remove('drag-target-bottom');
            // Confirm that drop target is another item in the same array as source item
            var sourceArrayIndex = +sessionStorage.getItem(this.arrayPointer);
            if (sourceArrayIndex !== this.dataIndex[this.dataIndex.length - 1]) {
                // Move array item
                this.jsf.moveArrayItem(this, sourceArrayIndex, this.dataIndex[this.dataIndex.length - 1]);
            }
            sessionStorage.removeItem(this.arrayPointer);
        }
        return false;
    };
    return OrderableDirective;
}());
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], OrderableDirective.prototype, "orderable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], OrderableDirective.prototype, "formID", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], OrderableDirective.prototype, "layoutNode", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], OrderableDirective.prototype, "layoutIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], OrderableDirective.prototype, "dataIndex", void 0);
__decorate([
    HostListener('dragstart', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], OrderableDirective.prototype, "onDragStart", null);
__decorate([
    HostListener('dragover', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], OrderableDirective.prototype, "onDragOver", null);
__decorate([
    HostListener('dragend', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], OrderableDirective.prototype, "onDragEnd", null);
__decorate([
    HostListener('dragenter', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], OrderableDirective.prototype, "onDragEnter", null);
__decorate([
    HostListener('dragleave', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], OrderableDirective.prototype, "onDragLeave", null);
__decorate([
    HostListener('drop', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], OrderableDirective.prototype, "onDrop", null);
OrderableDirective = __decorate([
    Directive({
        selector: '[orderable]',
    }),
    __metadata("design:paramtypes", [ElementRef,
        JsonSchemaFormService])
], OrderableDirective);
export { OrderableDirective };
//# sourceMappingURL=/home/samuel/repos/glaucoma_risk_calculator/glaucoma-risk-calc-web-frontend/src/node_modules/angular2-json-schema-form/src/library/utilities/orderable.directive.js.map