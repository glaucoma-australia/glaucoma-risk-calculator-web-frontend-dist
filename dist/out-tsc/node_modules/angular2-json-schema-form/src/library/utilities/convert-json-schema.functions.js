/**
 * 'convertJsonSchema3to4' function
 *
 * Converts JSON Schema version 3 to JSON Schema version 4
 *
 * Based on geraintluff's JSON Schema compatibility function
 * https://github.com/geraintluff/json-schema-compatibility
 *
 * @param {object} originalSchema - JSON schema (version 3 or 4)
 * @return {object} - JSON schema (version 4)
 */
/**
 * 'convertJsonSchema3to4' function
 *
 * Converts JSON Schema version 3 to JSON Schema version 4
 *
 * Based on geraintluff's JSON Schema compatibility function
 * https://github.com/geraintluff/json-schema-compatibility
 *
 * @param {object} originalSchema - JSON schema (version 3 or 4)
 * @return {object} - JSON schema (version 4)
 */ export function convertJsonSchema3to4(schema) {
    var isArray = function (item) { return Array.isArray(item) ||
        Object.prototype.toString.call(item) === '[object Array]'; };
    var convertTypes = function (types, replace) {
        if (replace === void 0) { replace = false; }
        var newTypes = [];
        for (var _i = 0, _a = isArray(types) ? types : [types]; _i < _a.length; _i++) {
            var type = _a[_i];
            if (typeof type === 'object') {
                newTypes.push(type);
                replace = true;
            }
            else {
                newTypes.push({ 'type': type });
            }
        }
        return replace && newTypes;
    };
    if (typeof schema !== 'object') {
        return schema;
    }
    var newSchema = isArray(schema) ? [].concat(schema) : Object.assign({}, schema);
    var converted = false;
    // convert multiple types to anyOf
    if (newSchema.type) {
        if (typeof newSchema.type !== 'string') {
            converted = true;
            var anyOf = convertTypes(newSchema.type);
            if (anyOf) {
                newSchema.anyOf = anyOf;
                delete newSchema.type;
            }
        }
        else if (newSchema.type === 'any') {
            delete newSchema.type;
        }
    }
    // convert extends to allOf
    if (newSchema.extends) {
        converted = true;
        newSchema.allOf = isArray(newSchema.extends) ?
            newSchema.extends : [newSchema.extends];
        delete newSchema.extends;
    }
    // convert disallow to not
    if (newSchema.disallow) {
        converted = true;
        newSchema.not = (typeof newSchema.disallow === 'string') ?
            { 'type': newSchema.disallow } :
            { 'anyOf': convertTypes(newSchema.disallow, true) };
        delete newSchema.disallow;
    }
    // move required from individual items to required array
    if (newSchema.properties) {
        var requiredArray = isArray(newSchema.required) ? newSchema.required : [];
        for (var _i = 0, _a = Object.keys(newSchema.properties); _i < _a.length; _i++) {
            var key = _a[_i];
            if (typeof newSchema.properties[key].required === 'boolean') {
                if (newSchema.properties[key].required) {
                    requiredArray.push(key);
                    converted = true;
                }
                delete newSchema.properties[key].required;
            }
        }
        if (requiredArray.length) {
            newSchema.required = requiredArray;
        }
    }
    // convert dependencies to arrays
    if (newSchema.dependencies) {
        for (var _b = 0, _c = Object.keys(newSchema.dependencies); _b < _c.length; _b++) {
            var key = _c[_b];
            if (typeof newSchema.dependencies[key] === 'string') {
                converted = true;
                newSchema.dependencies[key] = [newSchema.dependencies[key]];
            }
        }
    }
    // delete boolean required key
    if (typeof newSchema.required === 'boolean') {
        converted = true;
        delete newSchema.required;
    }
    // convert divisibleBy to multipleOf
    if (newSchema.divisibleBy) {
        converted = true;
        newSchema.multipleOf = newSchema.divisibleBy;
        delete newSchema.divisibleBy;
    }
    // convert sub schemas
    for (var _d = 0, _e = Object.keys(newSchema); _d < _e.length; _d++) {
        var key = _e[_d];
        if (['properties', 'patternProperties', 'dependencies'].indexOf(key) > -1) {
            for (var _f = 0, _g = Object.keys(newSchema[key]); _f < _g.length; _f++) {
                var subKey = _g[_f];
                newSchema[key][subKey] = convertJsonSchema3to4(newSchema[key][subKey]);
            }
        }
        else if (key !== 'enum') {
            if (isArray(newSchema[key])) {
                for (var _h = 0, _j = newSchema[key]; _h < _j.length; _h++) {
                    var subSchema = _j[_h];
                    subSchema = convertJsonSchema3to4(subSchema);
                }
            }
            else if (typeof newSchema[key] === 'object') {
                newSchema[key] = convertJsonSchema3to4(newSchema[key]);
            }
        }
    }
    if (converted === true) {
        // update or delete schema identifier
        if (newSchema.$schema) {
            if (newSchema.$schema === 'http://json-schema.org/draft-03/schema#') {
                newSchema.$schema = 'http://json-schema.org/draft-04/schema#';
            }
            else {
                delete newSchema.$schema;
            }
        }
        // update id
        if (newSchema.id) {
            newSchema.id += '-CONVERTED-TO-DRAFT-04';
        }
    }
    return newSchema;
}
//# sourceMappingURL=/home/samuel/repos/glaucoma_risk_calculator/glaucoma-risk-calc-web-frontend/src/node_modules/angular2-json-schema-form/src/library/utilities/convert-json-schema.functions.js.map